import{EventEmitter,Injectable}from '@angular/core';import{ethers,BigNumber,Contract,utils,providers}from 'ethers';import{default as sub_cons}from '../constants/token-lists/sub_cons.json';import{default as pop_cons}from '../constants/token-lists/pop_cons.json';import{contract_address,provider,signer}from '../constants/constants';import{pair_abi,factory_abi,routerV2_abi,contract_abi,pancakequoter,pancakeRouter_abi,pancakev2_lib_abi}from '../constants/abis/triangular.ABI';import{pancake_address}from '../constants/addresses/addresses';import{pancakeRouter}from '../constants/router/routers';import{_tokenAddress}from './bsscan';import{from,Observable}from 'rxjs';import{JsonEncoderService}from '../workers/json-encoder.service';import{AppComponent}from '../app.component';import{LineChartComponent}from '../line-chart/line-chart.component';import{Fetcher,ChainId}from "@pancakeswap/sdk";export let pancakePairPrice1:number=0;export let pancakePairPrice2:number=0;export let pancakePairPrice3:number=0;export let pancakeSwapTokenName:string;export let factory1!:ethers.Contract;export let factory2!:ethers.Contract;export let factory3!:ethers.Contract;type MapType={[id:string]:string}
export let pancakeTokenMap:MapType={};@Injectable({providedIn:'root'})
export class PancakeService{gas_price!:ethers.BigNumber;reserve:any;invokePair!:ethers.Contract;Mouter!:ethers.Contract;cumulative:number=0;shouldStart:boolean=!1;max_from_pairs:number=0;tokenAddress0:string='';tokenAddress1:string='';token0Name:string="";token1Name:string="";token2Name:string="";_pancakePairPrice:number=0;loop:boolean=!1;coin:string="";constructor(){}
switch1=!0;switch2=!0;switch3=!0;public async conventionSwitch(ops:string){switch(ops){case 'wbnb':break;case 'shiba':break;case 'eth':factory3=new ethers.Contract(pancake_address,factory_abi,signer);const getPair_3=await factory3.getPair(pop_cons.eth,pop_cons.busd);this.invokePair=new ethers.Contract(getPair_3,pair_abi,signer);this.reserve=await this.invokePair.getReserves();const reserve0_2=Number(ethers.utils.formatUnits(this.reserve[0],18));const reserve1_2=Number(ethers.utils.formatUnits(this.reserve[1],18));const quoteContract=new ethers.Contract('0x10ED43C718714eb63d5aA57B78B54704E256024E',pancakev2_lib_abi,signer);const amountIn=ethers.utils.parseUnits('1','ether');console.log('getAmounTIn');const getAmountIn=await quoteContract.getAmountIn(amountIn,this.reserve[0],this.reserve[1]);const _getAmountIn=Number(ethers.utils.formatUnits(getAmountIn,18))
console.log(_getAmountIn);console.log('getAmounTOut');const getAmountOut=await quoteContract.getAmountOut(amountIn,this.reserve[0],this.reserve[1]);const _getAmountOut=Number(ethers.utils.formatUnits(getAmountOut,18))
console.log(_getAmountOut);console.log('getAmountSIn');const getAmountsIn=await quoteContract.getAmountsIn(amountIn,[pop_cons.eth,pop_cons.busd]);console.log('getAmountsOut');console.log(getAmountsIn);console.log('getAmountSOut ');const getAmountsOut=await quoteContract.getAmountsOut(amountIn,[pop_cons.eth,pop_cons.busd]);console.log('getAmountsOut ');console.log(getAmountsOut);let amountIn1=ethers.utils.parseUnits("2",18);this.price_impact();break;default:console.log('Invalid operator')}
var line=new LineChartComponent();line.lineChart(pancakePairPrice1,pancakePairPrice2,pancakePairPrice3)}
price_impact(){const poolAddress='0xa39af17ce4a8eb807e076805da1e2b8ea7d0755b';const poolContract=new ethers.Contract(poolAddress,['function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast)'],signer);poolContract.getReserves().then((reserves:{_reserve0:ethers.BigNumberish;_reserve1:ethers.BigNumberish})=>{let reserve_a_initial=parseFloat(utils.formatUnits(reserves._reserve0));let reserve_b_initial=parseFloat(utils.formatUnits(reserves._reserve1));console.log(`CAKE in pool: ${reserve_a_initial}`);console.log(`USDT in pool: ${reserve_b_initial}`);const fee=0.02;let max_price_impact=0.001;let amount_traded_cake=reserve_a_initial*max_price_impact/((1-max_price_impact)*(1-fee));let amount_traded_usdt=reserve_b_initial*max_price_impact/((1-max_price_impact)*(1-fee));console.log(`Given a max price impact of ${max_price_impact*100}%, the max amount of CAKE tradeable is ${amount_traded_cake}`);console.log(`Given a max price impact of ${max_price_impact*100}%, the max amount of USDT tradeable is ${amount_traded_usdt}`);let amountInCAKE=amount_traded_cake*(1-fee);let amountInUSDT=amount_traded_usdt*(1-fee);let price_impact_trade_cake=amountInCAKE/(reserve_a_initial+amountInCAKE);let price_impact_trade_usdt=amountInUSDT/(reserve_b_initial+amountInUSDT);console.log(`Price impact when trading ${amount_traded_cake} CAKE: ${price_impact_trade_cake*100}%`);console.log(`Price impact when trading ${amount_traded_usdt} USDT: ${price_impact_trade_usdt * 100}%`)}).catch(console.error)}
async router(){this.Mouter=new ethers.Contract(pancakeRouter,routerV2_abi,signer)}}
